#!/usr/bin/env bash
# Ref: Spatia-Witness-Router-Alpha
# Dispatches Claims based on domain metadata

ATOM_ID=$1
DB="${SENTINEL_DB:-.spatia/sentinel.db}"
LOG_FILE=".spatia/logs/witness.log"


if [ -z "$ATOM_ID" ]; then
    echo "Usage: $0 <atom_id>"
    exit 1
fi


if [ ! -f "$DB" ]; then
    printf "Error: Sentinel DB missing at %s.\n" "$DB"
    exit 1
fi

mkdir -p .spatia/logs

timestamp() {
  date "+%Y-%m-%dT%H:%M:%S%z"
}

# Fetch Domain (Use -r for raw output to avoid quotes if any, though sqlite usually raw by default for simple selects)
DOMAIN=$(sqlite3 "$DB" "SELECT domain FROM atoms WHERE id='$ATOM_ID';")

# Per-Atom Log
LOG_ID=${ATOM_ID//\//_} # Replace / with _
ATOM_LOG=".spatia/logs/${LOG_ID}.log"

# Fetch Content
CONTENT=$(sqlite3 "$DB" "SELECT content FROM atoms WHERE id='$ATOM_ID';")

if [ -z "$CONTENT" ]; then
    printf "Error: No content found for atom %s in DB %s\n" "$ATOM_ID" "$DB"
    exit 1
fi

# Start Log (Global)
printf "[%s] START Atom: %s Domain: %s\n" "$(timestamp)" "$ATOM_ID" "$DOMAIN" >> "$LOG_FILE"
printf "\033[1;33m[WITNESS]\033[0m Routing Atom: %s (Domain: %s)\n" "$ATOM_ID" "$DOMAIN"

# Phase III: Domain Dispatch
case "$DOMAIN" in
  "Register")
    printf "\033[1;36m[WITNESS]\033[0m Performing Register Symmetry Check...\n"
    if ! .spatia/bin/spatia-check-registers.py >> "$ATOM_LOG" 2>&1; then
        printf "\033[1;31m[WITNESS]\033[0m Symmetry Check Failed.\n"
        printf "Symmetry Check Failed\n" >> "$ATOM_LOG"
        RESULT="FAILURE"
        EXIT_CODE=1
    else
        printf "\033[1;32m[WITNESS]\033[0m Symmetry Check Passed.\n"
        # Chains to standard witness? Plan said: Dispatch to Hermetic Witness (Nix)
        # The original code continued to Nix after register check. 
        # But for Culinary we might want DIFFERENT logic.
        # Let's assume Register DOES continue to verification (Symmetry is a pre-check).
        : # Continue to visual verification
    fi
    ;;
  "Culinary")
    printf "\033[1;36m[WITNESS]\033[0m Performing Culinary Math Check...\n"
    # Culinary is purely the script check for now, maybe?
    # Plan said: "handler for Culinary domain to call witness-culinary.py"
    # Let's run the py script.
    if ! .spatia/bin/witness-culinary.py "$ATOM_ID" >> "$ATOM_LOG" 2>&1; then
         printf "\033[1;31m[WITNESS]\033[0m Culinary Check Failed.\n"
         RESULT="FAILURE"
         EXIT_CODE=1
         # Start Log (Global) already calls it FAILURE implicitly if we exit? 
         # We need to ensure we set EXIT_CODE
    else
         printf "\033[1;32m[WITNESS]\033[0m Culinary Check Passed.\n"
         # Culinary might NOT need visual verification? 
         # Let's assume it DOES NOT need the Nix visual verification if it's just math.
         # Or maybe it does? "Ensure that when the witness-culinary.py script finishes its mathematical check, the result is broadcast"
         # If we skip Nix, we set EXIT_CODE=0 and we are done.
         EXIT_CODE=0
         GOTO_CLEANUP=1
    fi
    ;;
esac

if [ "$EXIT_CODE" == "1" ]; then
    # Early failure in domain logic
    :
elif [ -z "$GOTO_CLEANUP" ]; then
    # Phase IV check: Verify if content is "Intent" (Slang B / Lisp)
    # If it is, we treat it as a valid "Blueprint" and skip Python verification.
    
    # Check for Lisp-like start (semicolon for intent key or open paren)
    # Check for Lisp-like start (semicolon for intent key or open paren)
    # Regex: Start of line, optional whitespace, followed by (, :, or ;
    REGEX='^[[:space:]]*[\(:;]'
    if [[ "$CONTENT" =~ $REGEX ]]; then
        printf "\033[1;35m[WITNESS]\033[0m Detected Intent/Blueprint (Slang B). Skipping Python verification.\n"
        printf "[%s] Validated Intent Structure\n" "$(timestamp)" >> "$ATOM_LOG"
        EXIT_CODE=0
    else
        # Dispatch to Hermetic Witness (Nix) for visual/standard verification (Python/Slang A)
        # Capture output to per-atom log
        echo "$CONTENT" | nix-shell --pure .spatia/witness/shell.nix --run "python3 .spatia/witness/verify.py" >> "$ATOM_LOG" 2>&1
        EXIT_CODE=$?
    fi
fi

# Append atom log content to global log for posterity (optional, but good for trace)
cat "$ATOM_LOG" >> "$LOG_FILE"

if [ $EXIT_CODE -eq 0 ]; then
    RESULT="SUCCESS"
else
    RESULT="FAILURE"
fi

# End Log
printf "[%s] END Atom: %s Result: %s ExitCode: %d\n" "$(timestamp)" "$ATOM_ID" "$RESULT" "$EXIT_CODE" >> "$LOG_FILE"

if [ $EXIT_CODE -eq 0 ]; then
    printf "\033[1;32m[WITNESS]\033[0m Verification Passed.\n"
else
    printf "\033[1;31m[WITNESS]\033[0m Verification Failed.\n"
fi

exit $EXIT_CODE
